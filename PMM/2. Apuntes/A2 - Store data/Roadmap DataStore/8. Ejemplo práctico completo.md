### **8. Ejemplo prÃ¡ctico completo: Jetpack DataStore en configuraciÃ³n de Tema Oscuro**

ğŸ“Œ **Objetivo:** Implementar **Jetpack DataStore** para gestionar las preferencias de usuario, especÃ­ficamente el **modo oscuro** en la aplicaciÃ³n.

âœ… **CaracterÃ­sticas del ejemplo:**

- **Guardar y leer preferencias** del modo oscuro con `DataStore`.
- **Implementar ViewModel** para manejar las preferencias de forma reactiva.
- **Aplicar el tema en la UI automÃ¡ticamente** al cambiar el valor en DataStore.

---

## **ğŸ“Œ 1. ImplementaciÃ³n de DataStore para preferencias de usuario**

### **ğŸ“ Paso 1: Agregar dependencia en `build.gradle`**

Antes de empezar, asegÃºrate de que tienes la dependencia de DataStore en tu `build.gradle (Module: app)`:

```gradle
dependencies {
    implementation("androidx.datastore:datastore-preferences:1.0.0")
}
```

---

### **ğŸ“ Paso 2: Crear `UserPreferencesDataStore`**

Esta clase gestionarÃ¡ el almacenamiento de preferencias del usuario.

```kotlin
class UserPreferencesDataStore(private val context: Context) {

    companion object {
        private val THEME_KEY = booleanPreferencesKey("dark_mode") // Clave para almacenar el modo oscuro
    }

    // Guardar preferencia de tema oscuro
    suspend fun saveThemePreference(isDarkMode: Boolean) {
        context.dataStore.edit { preferences ->
            preferences[THEME_KEY] = isDarkMode
        }
    }

    // Leer la preferencia con Flow
    val themeFlow: Flow<Boolean> = context.dataStore.data
        .catch { exception ->
            if (exception is IOException) {
                emit(emptyPreferences()) // Si hay error, devolver valores por defecto
            } else {
                throw exception
            }
        }
        .map { preferences ->
            preferences[THEME_KEY] ?: false // Si no hay valor guardado, usar `false`
        }
}
```

ğŸ“Œ **ExplicaciÃ³n:**

- `booleanPreferencesKey("dark_mode")` crea una clave para el modo oscuro.
- `saveThemePreference(isDarkMode: Boolean)` guarda la preferencia en DataStore.
- `themeFlow` devuelve un `Flow<Boolean>` que **emite actualizaciones automÃ¡ticas** cuando cambia el valor en DataStore.
- Se usa `catch {}` para manejar errores y evitar que la app se cierre si DataStore tiene problemas.
- `?: false` establece `false` como valor predeterminado si no hay un valor guardado.

---

## **ğŸ“Œ 2. Implementar ViewModel para manejar DataStore**

Creamos un `ViewModel` para acceder a `UserPreferencesDataStore` sin necesidad de tocar la UI directamente.

```kotlin
class UserPreferencesViewModel(private val userPreferencesDataStore: UserPreferencesDataStore) : ViewModel() {

    // Convertir el Flow de DataStore en LiveData para que pueda observarse en la UI
    val themeLiveData: LiveData<Boolean> = userPreferencesDataStore.themeFlow.asLiveData()

    // MÃ©todo para cambiar el tema
    fun toggleDarkMode(isDarkMode: Boolean) {
        viewModelScope.launch {
            userPreferencesDataStore.saveThemePreference(isDarkMode)
        }
    }
}
```

ğŸ“Œ **ExplicaciÃ³n:**

- `themeLiveData` convierte `Flow` en `LiveData` para facilitar su observaciÃ³n en la UI.
- `toggleDarkMode(isDarkMode: Boolean)` actualiza la preferencia en DataStore.
- `viewModelScope.launch {}` ejecuta la escritura de DataStore en un hilo secundario.

âœ… **Â¿Por quÃ© usar ViewModel?**  
âœ” Evita acceder a `DataStore` directamente desde la UI.  
âœ” Mantiene la lÃ³gica desacoplada de la `Activity`.  
âœ” `LiveData` permite reaccionar a los cambios automÃ¡ticamente.

---

## **ğŸ“Œ 3. Aplicar DataStore en la configuraciÃ³n de tema oscuro en la UI**

Ahora, en la `MainActivity`, observamos los cambios de DataStore y aplicamos el tema.

```kotlin
class MainActivity : AppCompatActivity() {

    private lateinit var viewModel: UserPreferencesViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Inicializar DataStore y ViewModel
        val userPreferencesDataStore = UserPreferencesDataStore(this)
        viewModel = UserPreferencesViewModel(userPreferencesDataStore)

        // Observamos el LiveData y aplicamos el tema
        viewModel.themeLiveData.observe(this) { isDarkMode ->
            setTheme(isDarkMode)
        }

        // BotÃ³n para cambiar el tema
        findViewById<Button>(R.id.toggleThemeButton).setOnClickListener {
            val newTheme = !(viewModel.themeLiveData.value ?: false)
            viewModel.toggleDarkMode(newTheme)
        }
    }

    // Aplicar el tema oscuro o claro
    private fun setTheme(isDarkMode: Boolean) {
        AppCompatDelegate.setDefaultNightMode(
            if (isDarkMode) AppCompatDelegate.MODE_NIGHT_YES
            else AppCompatDelegate.MODE_NIGHT_NO
        )
    }
}
```

ğŸ“Œ **ExplicaciÃ³n:**

- `viewModel.themeLiveData.observe(this) {}` observa cambios en la preferencia y aplica el tema.
- `findViewById<Button>(R.id.toggleThemeButton).setOnClickListener {}` cambia la preferencia cuando el usuario presiona el botÃ³n.
- `setTheme(isDarkMode: Boolean)` usa `AppCompatDelegate.setDefaultNightMode()` para aplicar el tema.

âœ… **Â¿Por quÃ© usar `AppCompatDelegate.setDefaultNightMode()`?**  
âœ” Permite cambiar el tema en **toda la aplicaciÃ³n** sin necesidad de reiniciar actividades.

---

## **ğŸ“Œ 4. Prueba de lectura/escritura en DataStore**

Para verificar que la configuraciÃ³n de **modo oscuro** se guarda y lee correctamente, podemos hacer una prueba sencilla:

### **1ï¸âƒ£ Iniciar la app**

- La primera vez, el tema deberÃ­a ser **claro** (porque el valor predeterminado es `false`).

### **2ï¸âƒ£ Presionar el botÃ³n para cambiar el tema**

- La UI deberÃ­a actualizarse a **modo oscuro** inmediatamente.

### **3ï¸âƒ£ Cerrar y volver a abrir la app**

- La aplicaciÃ³n deberÃ­a recordar la configuraciÃ³n de **modo oscuro** gracias a DataStore.

âœ… **Resultado esperado:**

- La app debe **recordar** la preferencia incluso si se cierra.
- Si el usuario cambia el tema, la app lo aplicarÃ¡ inmediatamente.

---

## **ğŸ“Œ 5. Bonus: Mejorando la arquitectura con Hilt**

Si quieres mejorar la arquitectura de la app, puedes usar **Hilt para inyectar `UserPreferencesDataStore`** en el `ViewModel`.

### **ğŸ“ Modifica `UserPreferencesViewModel` para recibir `UserPreferencesDataStore` con Hilt**

```kotlin
@HiltViewModel
class UserPreferencesViewModel @Inject constructor(
    private val userPreferencesDataStore: UserPreferencesDataStore
) : ViewModel() {
```

### **ğŸ“ Agrega un `@Module` para inyectar `UserPreferencesDataStore`**

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DataStoreModule {
    @Provides
    @Singleton
    fun provideUserPreferencesDataStore(@ApplicationContext context: Context): UserPreferencesDataStore {
        return UserPreferencesDataStore(context)
    }
}
```

ğŸ“Œ **Â¿Ventajas de usar Hilt?**  
âœ” **Elimina la inicializaciÃ³n manual de `UserPreferencesDataStore` en `MainActivity`**.  
âœ” **Mejor arquitectura y separaciÃ³n de responsabilidades**.

---

## **ğŸš€ ConclusiÃ³n**

âœ… **Implementamos DataStore** para manejar las preferencias del usuario.  
âœ… **Creamos un ViewModel** para desacoplar la lÃ³gica de UI.  
âœ… **Aplicamos automÃ¡ticamente el tema** al leer DataStore en `MainActivity`.  
âœ… **Probamos la funcionalidad** verificando que la preferencia se guarda y persiste tras cerrar la app.  
âœ… **(Bonus) Mejoramos la arquitectura con Hilt**.

ğŸ“Œ **Â¿Quieres agregar mÃ¡s funcionalidades, como idioma o tamaÃ±o de fuente?** ğŸš€