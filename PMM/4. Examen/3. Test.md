### **Pruebas Unitarias en Android Studio:**

> Las pruebas unitarias son pruebas **automatizadas** que verifican el funcionamiento de pequeñas unidades de código, como funciones o métodos. Estas pruebas se ejecutan localmente en tu computadora (sin necesidad de un dispositivo físico o emulador) y son rápidas porque no interactúan con la interfaz gráfica.

[[3.1 Introducción a las Pruebas con @Test y assert]]
---

### **1. ¿Qué necesitas para escribir pruebas unitarias?**

1. **Herramientas principales:**
    - **JUnit:** Es la librería más común para escribir pruebas en Java y Kotlin.
    - **Mockito:** Para simular dependencias (mocking).
    - **Truth (opcional):** Para crear aserciones más claras y legibles.
2. **Carpetas de pruebas:**
    - `src/test`: Para pruebas unitarias locales (no dependen de Android).
    - `src/androidTest`: Para pruebas instrumentadas que se ejecutan en un dispositivo/emulador.
3. **Dependencias necesarias:** Añade estas dependencias en tu archivo `build.gradle`:
    
```gradle
dependencies {
	testImplementation 'junit:junit:4.13.2'
	testImplementation 'org.mockito:mockito-core:4.8.1'
	testImplementation 'com.google.truth:truth:1.1.3'
	androidTestImplementation 'androidx.test.ext:junit:1.1.5'
	androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
}
```

---

### **2. Implementar pruebas unitarias básicas (locales)**

#### Ejemplo: Probar una función que calcula el descuento de un libro.

Supongamos que tienes una función en tu repositorio que calcula el descuento en el precio de un libro:

```kotlin
fun calcularDescuento(precio: Double, descuento: Double): Double {
    if (descuento < 0 || descuento > 100) {
        throw IllegalArgumentException("El descuento debe estar entre 0 y 100")
    }
    return precio - (precio * (descuento / 100))
}
```

#### **Paso 1: Escribir la prueba en `src/test`**

Crea un archivo `LibroRepositoryTest.kt` en la carpeta `src/test`.

```kotlin
import org.junit.Assert.assertEquals
import org.junit.Assert.assertThrows
import org.junit.Test

class LibroRepositoryTest {

    @Test
    fun calcularDescuento_valoresCorrectos_retornaPrecioConDescuento() {
        val resultado = calcularDescuento(100.0, 20.0)
        assertEquals(80.0, resultado, 0.001)
    }

    @Test
    fun calcularDescuento_descuentoInvalido_lanzaExcepcion() {
        assertThrows(IllegalArgumentException::class.java) {
            calcularDescuento(100.0, 120.0)
        }
    }
}
```

---

### **3. Pruebas instrumentadas (en `src/androidTest`)**

Las pruebas instrumentadas interactúan con el entorno de Android, lo que significa que puedes probar componentes como bases de datos, vistas (UI), etc., en un emulador o dispositivo físico.

#### Ejemplo: Probar la base de datos Room.

Supongamos que quieres probar que los datos se guardan correctamente en la tabla `libros`.

#### **Paso 1: Crear la prueba instrumentada**

Crea un archivo `AppDatabaseTest.kt` en `src/androidTest`.

```kotlin
import android.content.Context
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.app.data.local.AppDatabase
import com.example.app.data.local.Libro
import com.example.app.data.local.LibroDao
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class AppDatabaseTest {

    private lateinit var db: AppDatabase
    private lateinit var dao: LibroDao

    @Before
    fun crearBaseDeDatos() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        db = Room.inMemoryDatabaseBuilder(context, AppDatabase::class.java).build()
        dao = db.libroDao()
    }

    @After
    fun cerrarBaseDeDatos() {
        db.close()
    }

    @Test
    fun insertarYLeerLibro() = runBlocking {
        val libro = Libro(titulo = "El Principito", anio = 1943)
        dao.insertar(libro)

        val libros = dao.obtenerTodos().toList()
        assertEquals(1, libros.size)
        assertEquals("El Principito", libros[0].titulo)
    }
}
```

#### **Paso 2: Explicación del código**

- **`@RunWith(AndroidJUnit4::class)`**: Indica que es una prueba instrumentada.
- **`@Before` y `@After`**: Configuran y destruyen la base de datos en memoria antes y después de cada prueba.
- **`Room.inMemoryDatabaseBuilder`**: Crea una base de datos en memoria para pruebas (no persiste datos).
- **`runBlocking`**: Permite ejecutar funciones suspendidas en pruebas.

---

### **4. Diferencias entre pruebas unitarias y pruebas instrumentadas**

|Característica|Pruebas Unitarias|Pruebas Instrumentadas|
|---|---|---|
|**Ejecución**|Local, en la máquina del desarrollador|En un emulador o dispositivo físico|
|**Velocidad**|Muy rápida|Más lenta debido al entorno de Android|
|**Componentes probados**|Métodos y funciones aisladas|UI, bases de datos, y componentes de Android|
|**Dependencias del sistema**|No depende de Android|Sí depende de Android|
