### **ðŸ“Œ AnÃ¡lisis del `PlayersController` en relaciÃ³n con el enunciado**

El **`PlayersController`** implementa una API REST para gestionar jugadores en la NBA, pero presenta **algunas deficiencias** con respecto al enunciado. Vamos a analizar cada funciÃ³n y explicar si cumple o no con los requisitos.

---

## **ðŸ“Œ 1. ConfiguraciÃ³n General**

```java
@CrossOrigin(origins = "*")
@RestController
@RequestMapping("/nba")
```

âœ… **`@CrossOrigin(origins = "*")`**: Permite peticiones desde cualquier origen (CORS habilitado).  
âœ… **`@RestController`**: Indica que es un controlador REST.  
âœ… **`@RequestMapping("/nba")`**: Define el prefijo de la API, por lo que todos los endpoints estarÃ¡n bajo `/nba`.

---

## **ðŸ“Œ 2. `GET /nba/players` â†’ Obtener todos los jugadores**

```java
@GetMapping("/players")
public ResponseEntity<?> getAllPlayers() {
    List<Players> players = playerService.findAll();
    if (players.isEmpty()) {
        return ResponseEntity.noContent().build();
    } else {
        return new ResponseEntity<List<Players>>(players, HttpStatus.OK);
    }
}
```

âœ… **Cumple con el enunciado**

- Si hay jugadores, devuelve **200 OK** con la lista.
- Si no hay jugadores, devuelve **204 No Content**.

1. **No se deben mostrar las estadÃ­sticas del jugador.** Se debe excluir la lista de `Stats` para evitar **recursiÃ³n infinita**.
    - Usar `@JsonIgnore` en `Players` 
    ```java
    @JsonIgnore
	public Set<Stats> getStatses() {
		return this.statses;
	}
	```

2. **No se deben incluir los jugadores del equipo en la respuesta JSON.**
	```java
	@JsonIgnoreProperties("playerses")
	public Teams getTeams() {
		return this.teams;
	}
	```


---
## **ðŸ“Œ 3. `GET /nba/players/{id}` â†’ Obtener un jugador por ID**

```java
@GetMapping("/players/{id}")
public Players getPlayerById(@PathVariable int id) {
    return playerService.findById(id);
}
```

ðŸ”´ **Errores detectados:**

3. **No maneja el caso en que el jugador no existe.** SegÃºn el enunciado, deberÃ­a devolver **404 Not Found** si el ID no se encuentra.
    - **SoluciÃ³n:** Usar `ResponseEntity<Players>` y manejar la excepciÃ³n.
4. **No evita la recursiÃ³n JSON.**
    - **SoluciÃ³n:** Usar `@JsonIgnoreProperties({"stats", "team.players"})` en `Players`.

**CorrecciÃ³n:**

```java
@GetMapping("/players/{id}")
public ResponseEntity<Players> getPlayerById(@PathVariable int id) {
    Optional<Players> player = Optional.ofNullable(playerService.findById(id));
    return player.map(ResponseEntity::ok).orElseGet(() -> ResponseEntity.notFound().build());
}
```

---

## **ðŸ“Œ 4. `POST /nba/players` â†’ Crear un nuevo jugador**

```java
@PostMapping("/players")
@ResponseStatus(HttpStatus.CREATED)
public Players create(@RequestBody Players pla) {
    playerService.save(pla);
    return pla;
}
```

âœ… **Cumple parcialmente**  
ðŸ”´ **Errores detectados:**

5. **No maneja datos incorrectos (`400 Bad Request`).**
    - **SoluciÃ³n:** Verificar que el JSON sea vÃ¡lido y tenga los datos requeridos antes de guardar.
6. **No devuelve `ResponseEntity` con la ubicaciÃ³n del recurso creado.**
    - **SoluciÃ³n:** Devolver `201 Created` con `Location` en el header.

**CorrecciÃ³n:**

```java
@PostMapping("/players")
public ResponseEntity<Players> create(@RequestBody Players pla) {
    if (pla.getName() == null || pla.getPosition() == null) {
        return ResponseEntity.badRequest().build(); // 400 Bad Request si faltan datos
    }
    Players savedPlayer = playerService.save(pla);
    return ResponseEntity.status(HttpStatus.CREATED).body(savedPlayer);
}
```

---

## **ðŸ“Œ 5. `DELETE /nba/players/{id}` â†’ Borrar un jugador por ID**

```java
@DeleteMapping("/players/{id}")
@ResponseStatus(HttpStatus.NO_CONTENT)
public void delete(@PathVariable int id) {
    Players play = playerService.findById(id);
    playerService.delete(play);
}
```

ðŸ”´ **Errores detectados:**

7. **No maneja el caso en que el jugador no existe (`404 Not Found`).**
8. **No elimina las estadÃ­sticas del jugador antes de borrarlo.**
    - **SoluciÃ³n:** Configurar **cascade delete** en `@OneToMany(mappedBy = "player", cascade = CascadeType.ALL, orphanRemoval = true)` en la entidad `Players`.

**CorrecciÃ³n:**

```java
@DeleteMapping("/players/{id}")
public ResponseEntity<Void> delete(@PathVariable int id) {
    Optional<Players> player = Optional.ofNullable(playerService.findById(id));
    if (player.isPresent()) {
        playerService.delete(player.get());
        return ResponseEntity.noContent().build(); // 204 No Content
    }
    return ResponseEntity.notFound().build(); // 404 Not Found
}
```

---

## **ðŸ“Œ 6. `PUT /nba/players/{id}` â†’ Modificar un jugador por ID**

```java
@PutMapping("/players/{id}")
public Players update(@RequestBody Players pla,@PathVariable int id) {
    Players currentPlay = playerService.findById(id);
    currentPlay.setCode(pla.getCode());
    currentPlay.setName(pla.getName());
    currentPlay.setOrigin(pla.getOrigin());
    currentPlay.setHeight(pla.getHeight());
    currentPlay.setWeight(pla.getWeight());
    currentPlay.setPosition(pla.getPosition());
    currentPlay.setSalary(pla.getSalary());
    playerService.save(currentPlay);
    return currentPlay;
}
```

ðŸ”´ **Errores detectados:**

9. **No maneja el caso en que el jugador no existe (`404 Not Found`).**
10. **No maneja datos incorrectos (`400 Bad Request`).**
11. **No devuelve `ResponseEntity`.**

**CorrecciÃ³n:**

```java
@PutMapping("/players/{id}")
public ResponseEntity<Players> update(@PathVariable int id, @RequestBody Players pla) {
    Optional<Players> existingPlayer = Optional.ofNullable(playerService.findById(id));
    
    if (existingPlayer.isPresent()) {
        Players player = existingPlayer.get();
        player.setName(pla.getName());
        player.setOrigin(pla.getOrigin());
        player.setHeight(pla.getHeight());
        player.setWeight(pla.getWeight());
        player.setPosition(pla.getPosition());
        player.setSalary(pla.getSalary());

        playerService.save(player);
        return ResponseEntity.ok(player);
    }
    return ResponseEntity.notFound().build();
}
```

---

## **ðŸ“Œ 7. Manejo de Excepciones con `PlayerNotFoundException`**

```java
@ExceptionHandler(PlayerNotFoundException.class)
@ResponseBody
public ResponseEntity<Map<String, Object>> handleException(PlayerNotFoundException pnfe) {
    Map<String, Object> response = new HashMap<>();
    response.put("message", pnfe.getMessage());
    return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
}
```

âœ… **Bien implementado**  
ðŸ”´ **No estÃ¡ siendo utilizado en `getPlayerById()` ni en `delete()`.**

- **SoluciÃ³n:** Lanzar `PlayerNotFoundException` en `playerService.findById(id)`.

---

## **ðŸ“Œ Faltan Endpoints**

ðŸ”´ **No estÃ¡n implementados los endpoints para estadÃ­sticas (`/players/{id}/stats`).**

- **Faltan:**
    - `GET /players/{id}/stats` â†’ Obtener estadÃ­sticas de un jugador.
    - `POST /players/{id}/stats` â†’ Agregar una estadÃ­stica.

**Ejemplo de implementaciÃ³n para `GET /players/{id}/stats`**

```java
@GetMapping("/players/{id}/stats")
public ResponseEntity<List<Stats>> getPlayerStats(@PathVariable int id) {
    Optional<Players> player = Optional.ofNullable(playerService.findById(id));
    return player.map(p -> ResponseEntity.ok(p.getStatses()))
                 .orElseGet(() -> ResponseEntity.notFound().build());
}
```

---

## **ðŸ“Œ ConclusiÃ³n**

ðŸ”¹ **El controlador estÃ¡ bien estructurado pero tiene errores que deben corregirse.**  
ðŸ”¹ **Faltan validaciones en `GET`, `POST`, `PUT`, `DELETE`.**  
ðŸ”¹ **No se han implementado los endpoints para estadÃ­sticas.**  
ðŸ”¹ **Se debe evitar la recursiÃ³n infinita en JSON.**

ðŸš€ **Â¿Quieres que implemente los endpoints faltantes?**