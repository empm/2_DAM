# **üìå Gesti√≥n y Manejo de Excepciones en Spring Boot con Hibernate**

Cuando desarrollamos una API en **Spring Boot con Hibernate**, pueden ocurrir errores en distintos niveles:

- **Errores de Base de Datos** (conexi√≥n, restricciones, claves primarias).
- **Errores de Negocio** (datos inv√°lidos, entidad no encontrada).
- **Errores de Programaci√≥n** (null pointers, excepciones no controladas).

Para gestionarlas correctamente, usamos **Manejo de Excepciones** con **Spring Boot**.

---

## **1Ô∏è‚É£ Paso 1: Identificar los Tipos de Excepciones**

### **Ejemplo en el Proyecto NBA**

üìå **Algunos errores comunes al trabajar con la API de la NBA:**

1. **Buscar un equipo que no existe ‚Üí `EntityNotFoundException`**
2. **Intentar crear un equipo con el mismo nombre ‚Üí `DataIntegrityViolationException`**
3. **Conexi√≥n a la base de datos fallida ‚Üí `SQLException`**
4. **Errores generales ‚Üí `Exception`**

---

## **2Ô∏è‚É£ Paso 2: Usar `@ExceptionHandler` en el Controlador**

Si queremos capturar **errores espec√≠ficos** dentro de un **controlador**, usamos `@ExceptionHandler`.

```java
@RestController
@RequestMapping("/nba/teams")
public class TeamsController {

    @Autowired
    private ITeamsService teamsService;

    @GetMapping("/{name}")
    public ResponseEntity<Teams> getTeamById(@PathVariable String name) {
        Teams team = teamsService.findById(name);
        if (team == null) {
            throw new EntityNotFoundException("Equipo con nombre " + name + " no encontrado");
        }
        return ResponseEntity.ok(team);
    }

    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<String> handleNotFoundException(EntityNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
    }
}
```

üìå **Explicaci√≥n:**

- **Si el equipo no existe**, lanzamos `EntityNotFoundException`.
- **El m√©todo `handleNotFoundException`** captura esta excepci√≥n y devuelve un **mensaje amigable** al usuario con c√≥digo `404`.

---

## **3Ô∏è‚É£ Paso 3: Crear una Clase Global para Manejar Excepciones**

En lugar de manejar errores **en cada controlador**, **creamos una clase global** con `@ControllerAdvice` que captura **todas** las excepciones de la API.

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<String> handleEntityNotFound(EntityNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<String> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Error de integridad en la base de datos");
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGlobalException(Exception ex) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error interno del servidor");
    }
}
```

üìå **Explicaci√≥n:**

- üìå **`@RestControllerAdvice`** ‚Üí Indica que esta clase maneja **todas las excepciones de la API**.
- üìå **M√©todos `@ExceptionHandler`** ‚Üí Capturan distintos tipos de excepciones:
    - `EntityNotFoundException` ‚Üí Devuelve `404 Not Found`.
    - `DataIntegrityViolationException` ‚Üí Devuelve `400 Bad Request`.
    - `Exception` (general) ‚Üí Devuelve `500 Internal Server Error`.

---

## **4Ô∏è‚É£ Paso 4: Propagar Excepciones Personalizadas en el Service**

En **TeamsServiceImpl**, si no encontramos el equipo, lanzamos una **excepci√≥n personalizada**.

```java
@Service
public class TeamsServiceImpl implements ITeamsService {

    @Autowired
    private ITeamsDAO teamsDAO;

    @Override
    public Teams findById(String name) {
        return teamsDAO.findById(name)
                .orElseThrow(() -> new EntityNotFoundException("El equipo " + name + " no existe"));
    }
}
```

üìå **Explicaci√≥n:**

- Si el equipo **NO** existe, usamos **`orElseThrow`** para lanzar una `EntityNotFoundException`.

---

## **5Ô∏è‚É£ Paso 5: Validar Datos Antes de Guardar**

Cuando creamos un nuevo equipo, es importante validar que los datos sean correctos antes de insertarlos en la base de datos.

```java
@Override
public void save(Teams team) {
    if (team.getName() == null || team.getName().isEmpty()) {
        throw new IllegalArgumentException("El nombre del equipo no puede estar vac√≠o");
    }
    teamsDAO.save(team);
}
```

üìå **Explicaci√≥n:**

- Si el **nombre est√° vac√≠o**, lanzamos una `IllegalArgumentException` para evitar errores en la base de datos.

---

# **üìå Resumen Paso a Paso**

‚úÖ **1Ô∏è‚É£ Identificar los errores comunes** en la API.  
‚úÖ **2Ô∏è‚É£ Manejar excepciones dentro del Controlador** con `@ExceptionHandler`.  
‚úÖ **3Ô∏è‚É£ Crear una clase global de manejo de excepciones** con `@RestControllerAdvice`.  
‚úÖ **4Ô∏è‚É£ Propagar excepciones desde el Service** con `orElseThrow()`.  
‚úÖ **5Ô∏è‚É£ Validar datos antes de guardar** para evitar errores en la base de datos.

---

# **üöÄ Beneficios de Manejar Excepciones**

‚úî **API m√°s robusta** ‚Üí Se evitan ca√≠das inesperadas.  
‚úî **Respuestas amigables** ‚Üí Se env√≠an mensajes claros al usuario.  
‚úî **Facilidad de depuraci√≥n** ‚Üí Se identifican errores r√°pidamente.
