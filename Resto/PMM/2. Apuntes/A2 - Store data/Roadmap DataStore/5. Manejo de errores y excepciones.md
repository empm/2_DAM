### **5. Manejo de errores y excepciones en Preferences DataStore**

Cuando trabajamos con **Jetpack DataStore**, es importante manejar los posibles errores que pueden ocurrir durante la lectura y escritura de datos. Si no se controlan adecuadamente, estos errores pueden causar fallos inesperados en la aplicaci√≥n.

En este punto aprender√°s:  
‚úî C√≥mo manejar **errores de lectura** al recuperar datos.  
‚úî C√≥mo controlar **fallos en la escritura** de datos.  
‚úî Qu√© hacer cuando se detecta **corrupci√≥n de datos**.

---

## **5.1 Errores en la lectura de datos (`IOException`)**

El error m√°s com√∫n al leer datos en DataStore ocurre cuando el archivo de preferencias est√° corrupto o no se puede acceder. Para manejar esto, utilizamos **Flow con `catch {}`** para interceptar las excepciones y proporcionar un valor por defecto.

### **Ejemplo: Manejo de errores en la lectura de datos**

```kotlin
val themeFlow: Flow<Boolean> = context.dataStore.data
    .catch { exception ->
        if (exception is IOException) {
            emit(false) // Si hay error, devolver 'false' como valor por defecto
        } else {
            throw exception // Si es otro error, relanzarlo
        }
    }
    .map { preferences ->
        preferences[THEME_KEY] ?: false
    }
```

üìå **Explicaci√≥n:**

- `catch {}` captura cualquier excepci√≥n que ocurra en la lectura de datos.
- Si el error es de tipo **`IOException`** (problema de lectura de archivo), se emite un **valor por defecto** (`false`).
- Si el error **no es un `IOException`**, se relanza (`throw exception`) para que la app lo maneje de otra forma.

‚úÖ **Beneficio**: Garantiza que la app **no crashee** si el archivo se da√±a o no puede accederse.

---

## **5.2 Errores en la escritura de datos**

Cuando escribimos datos en DataStore, puede ocurrir una **excepci√≥n** si hay un problema con el almacenamiento o si el dispositivo no permite la escritura en ese momento.

### **Ejemplo: Manejo de errores en la escritura**

```kotlin
suspend fun saveThemePreference(isDarkMode: Boolean) {
    try {
        context.dataStore.edit { preferences ->
            preferences[THEME_KEY] = isDarkMode
        }
    } catch (exception: IOException) {
        Log.e("SettingsDataStore", "Error al guardar en DataStore", exception)
    }
}
```

üìå **Explicaci√≥n:**

- Se envuelve `edit {}` en un bloque `try-catch`.
- Si ocurre un **`IOException`**, se captura y se muestra un mensaje de error en el `Log`.
- **No se relanza la excepci√≥n**, ya que el error puede no ser cr√≠tico para la app.

‚úÖ **Beneficio**: La app no se bloquea si hay un error de almacenamiento.

---

## **5.3 C√≥mo manejar datos corruptos en DataStore**

Si el archivo de preferencias se corrompe, DataStore puede lanzar una excepci√≥n. Para evitar que la app se rompa, podemos **emitir valores por defecto** cuando el archivo est√° da√±ado.

### **Ejemplo: Detectar y solucionar datos corruptos**

```kotlin
val themeFlow: Flow<Boolean> = context.dataStore.data
    .catch { exception ->
        when (exception) {
            is CorruptionException -> {
                Log.e("DataStore", "Archivo corrupto, usando valores por defecto")
                emit(false) // Enviar un valor seguro por defecto
            }
            is IOException -> {
                Log.e("DataStore", "Error de lectura, usando valores por defecto")
                emit(false)
            }
            else -> throw exception // Relanzar otros errores
        }
    }
    .map { preferences ->
        preferences[THEME_KEY] ?: false
    }
```

üìå **Explicaci√≥n:**

- `CorruptionException`: Se lanza cuando el archivo de preferencias est√° **da√±ado**.
- `IOException`: Se lanza si hay un **problema de acceso al archivo**.
- **Se devuelve un valor por defecto** (`emit(false)`) para mantener la app funcionando.

‚úÖ **Beneficio**: Permite que la app siga funcionando incluso si el archivo est√° corrupto.

---

## **5.4 Uso de valores predeterminados para evitar errores**

Una buena pr√°ctica en DataStore es **definir valores predeterminados** en caso de que los datos no existan.

### **Ejemplo: Definir valores predeterminados con `?:` (Elvis Operator)**

```kotlin
val themeFlow: Flow<Boolean> = context.dataStore.data.map { preferences ->
    preferences[THEME_KEY] ?: false // Si no existe, usar 'false' como valor predeterminado
}
```

üìå **Explicaci√≥n:**

- `?:` (Elvis Operator) asigna `false` si el valor no ha sido guardado previamente.

‚úÖ **Beneficio**: Asegura que la app no devuelva valores `null` inesperadamente.

---

## **5.5 Resumen de estrategias para manejar errores en DataStore**

|Tipo de Error|Causa|Soluci√≥n|
|---|---|---|
|`IOException`|Fallo de acceso al archivo|Usar `catch {}` y devolver un valor por defecto (`emit(valor_defecto)`)|
|`CorruptionException`|Archivo da√±ado|Capturar la excepci√≥n y emitir valores predeterminados|
|Escritura fallida|Problema de almacenamiento|Envolver `edit {}` en un `try-catch`|
|Valor no encontrado|Clave no definida|Usar `?:` para asignar valores predeterminados|

‚úÖ **Conclusi√≥n:**  
El uso de `catch {}` en Flow y `try-catch` en `edit {}` es la mejor estrategia para evitar que la app falle si hay problemas de almacenamiento.

---

üöÄ **¬øQuieres que avancemos al punto 6 (Migraci√≥n desde SharedPreferences) o necesitas m√°s ejemplos?**