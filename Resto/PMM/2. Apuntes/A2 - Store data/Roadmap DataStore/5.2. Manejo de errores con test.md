# **Manejo de errores en DataStore con Testing**

Para asegurarnos de que el manejo de errores en **Jetpack DataStore** funciona correctamente, podemos escribir **tests unitarios** usando **JUnit y coroutines**.

---

## **1Ô∏è‚É£ Dependencias necesarias**

Para escribir pruebas con DataStore, necesitas agregar en `build.gradle` (m√≥dulo app):

```gradle
testImplementation "junit:junit:4.13.2"
testImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.6.4"
testImplementation "androidx.test.ext:junit:1.1.5"
testImplementation "androidx.test.core:1.5.0"
```

---

## **2Ô∏è‚É£ Crear una versi√≥n de DataStore para pruebas**

Como DataStore usa archivos internos, en los tests podemos usar **`TestCoroutineScope`** y **`MutablePreferences`** para simular el almacenamiento.

```kotlin
@ExperimentalCoroutinesApi
class SettingsDataStoreTest {

    private val testContext = TestCoroutineDispatcher()
    private val testScope = TestCoroutineScope(testContext)

    private val testDataStore = PreferenceDataStoreFactory.create(
        scope = testScope,
        produceFile = { File("test.preferences_pb") } // Archivo temporal de prueba
    )

    private val THEME_KEY = booleanPreferencesKey("dark_mode")

    @After
    fun cleanup() {
        testScope.cleanupTestCoroutines()
    }
}
```

üìå **Explicaci√≥n:**

- `PreferenceDataStoreFactory.create()` permite **crear un DataStore en memoria para pruebas**.
- `testScope.cleanupTestCoroutines()` limpia las corrutinas al final de cada test.

---

## **3Ô∏è‚É£ Probar escritura y lectura de datos**

Podemos probar si los valores se guardan y recuperan correctamente.

```kotlin
@Test
fun testSaveAndRetrieveThemePreference() = runBlockingTest {
    // Guardar en DataStore
    testDataStore.edit { preferences ->
        preferences[THEME_KEY] = true
    }

    // Leer el valor guardado
    val result = testDataStore.data.first()[THEME_KEY]

    // Verificar que el valor es el esperado
    assertEquals(true, result)
}
```

üìå **Explicaci√≥n:**

- `testDataStore.edit {}` simula la escritura en DataStore.
- `testDataStore.data.first()` obtiene el valor actual del archivo de prueba.
- `assertEquals(true, result)` verifica que el dato guardado es correcto.

---

## **4Ô∏è‚É£ Probar manejo de errores en lectura (IOException)**

Para simular un error de lectura, podemos lanzar una excepci√≥n intencionalmente.

```kotlin
@Test
fun testReadErrorHandling() = runBlockingTest {
    val failingDataStore = PreferenceDataStoreFactory.create(
        scope = testScope,
        produceFile = { throw IOException("Error simulado") } // Simulamos un fallo
    )

    val flow = failingDataStore.data.catch { emit(emptyPreferences()) }.first()

    // Verificamos que se devuelve un valor vac√≠o en caso de error
    assertEquals(emptyPreferences(), flow)
}
```

üìå **Explicaci√≥n:**

- Se lanza un **IOException simulado** al intentar acceder al archivo.
- Se captura el error con `catch { emit(emptyPreferences()) }` y se emite un valor vac√≠o.
- **Se verifica** que, en caso de error, se recibe `emptyPreferences()`.

---

## **üöÄ Resumen de pruebas en DataStore**

‚úÖ **Probar escritura y lectura de datos correctamente.**  
‚úÖ **Simular errores de lectura (`IOException`).**  
‚úÖ **Verificar que DataStore emite valores predeterminados en caso de fallo.**
