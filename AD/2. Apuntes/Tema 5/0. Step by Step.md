# 1. Instalar MySQL

> Descarga MySQL desde [mysql.com/downloads](https://www.mysql.com/downloads/)

 - Instala el servidor
 - Configura el usuario `root` con contraseña segura y anótala.
 - Levanta el servidor

# 2. Crear la base de datos
> Para los apuntes 5.1 y 5.2 se usa de ejemplo la base de datos de "departamentos".

```SQL
CREATE DATABASE departamentos;

CREATE TABLE departamentos (
    Dept_num INT NOT NULL PRIMARY KEY,
    Name VARCHAR(20),
    Office VARCHAR(20)
);

CREATE TABLE profesores (
    id INT NOT NULL PRIMARY KEY,
    Name VARCHAR(15),
    Surname VARCHAR(40),
    Email VARCHAR(50),
    Start_date DATE,
    Dept_num INT,
    FOREIGN KEY (Dept_num) REFERENCES departamentos(Dept_num)
);

INSERT INTO departamentos
VALUES 
(10, 'INFORMATICA', 'DESPA6'),
(20, 'COMERCIO', 'DESPA7'),
(30, 'ADMINISTRATIVO', 'DESPA8'),
(40, 'FOL', 'DESPA5');

INSERT INTO profesores
VALUES 
(1, 'Luz', 'Martinez', 'luz.martinez@iesabastos.org', '1990-01-01', 10),
(2, 'Cristina', 'Ausina', 'c.ausina@iesabastos.org', '1990-02-01', 10),
(3, 'Imma', 'Cabanes', 'i.cabanes@iesabastos.org', '1990-03-01', 10);

INSERT INTO profesores (id, name, surname, email, Dept_num)
VALUES (4, 'Mercedes', 'Sánchez', 'm.sanchez@iesabastos.org', 40);
```

# 3. Configurar Eclipse

> Go to `Help > Install New Software` and paste this repository URL into the dialog:
- `https://cdn.spring.io/spring-tools/release/TOOLS/sts4/update/latest`

> Got to `Help > Eclipse Marketplace`
- Spring Tools 4: 
	- https://marketplace.eclipse.org/content/spring-tools-4-aka-spring-tool-suite-4
- JBoss Tools: 
	- https://marketplace.eclipse.org/content/jboss-tools
- Debug Perspective Auto Closer:
	- https://marketplace.eclipse.org/content/debug-perspective-auto-closer

>[!Enlace]
>https://github.com/spring-projects/sts4/wiki/Installation


# 4. Crear un nuevo proyecto de Spring
## 1. Crear proyecto
> ir a `New > Spring Starter Project`

![[Pasted image 20250124181454.png]]

> [!Important]
> Grupo de ejemplo: `com.eperez`
> Package: `com.eperez.mvc`
> Incluir `mvc` al final del grupo

> `Next`

## 2. Instalar dependencias

- Version: última estable (NO SNAPSHOT NI RC)
- Developer Tools > Spring Boot DevTools
- SQL > Spring Data JPA
- SQL > MySql Driver
- Web > Spring Web

> `Finish`

Dentro de `com.backend.mvc` se habrá creado el archivo con la etiqueta `@SpringBootApplication`.

## 3. Crear paquetes

> Dentro de `/src/main/java`, crear:

- Controladores: `com.eperez.mvc.controllers`
- Servicios: `com.eperez.mvc.model.services
- Repositorios (DAO): `com.eperez.mvc.model.dao
- Entidades: `com.eperez.mvc.model.entity

## 4. Configurar propiedades DB

> Configurar fichero `application.properties` ubicado en `src/main/resources`. Clic en `Source`para pegar los siguientes datos:

```
spring.application.name=<NOMBRE_DEL_PROYECTO>
spring.datasource.url=jdbc:mysql://localhost/<NOMBRE_DATABASE_>
spring.datasource.username=root
spring.datasource.password=contraseñaMySQL
logging.level.org.hibernate.SQL=debug
spring.jackson.serialization.fail-on-empty-beans=false
```


# 5. Hibernate

> **Hibernate** es una herramienta de mapeo objeto-relacional (ORM) que conecta clases de Java con tablas de bases de datos relacionales. 

## **1. Crear archivo de configuración (cfg.xml)**

> El archivo hibernate.cfg.xml contiene las configuraciones necesarias para que Hibernate se conecte a la base de datos. Aquí defines:

• La URL de la base de datos.
• El usuario y la contraseña.
• El driver JDBC.
• Configuraciones adicionales como el dialecto SQL.

Es la base de la comunicación entre tu aplicación y la base de datos. Sin este archivo, Hibernate no puede saber cómo conectarse o qué base de datos utilizar.

---
### Proceso

> Dentro de `com.eperez.mvc.model.entity`

Clic derecho sobre el paquete y crear `Hibernate Configuration File (cfg.xml)`.

![[Pasted image 20250124183956.png]]

- Hibernate version: `6.5`
- Session factory name: `HibernateConfig`
- Database dialect: `MySQL`
- Driver class: `com.mysql.jdbc.Driver`
- Connection URL: `jdbc:mysql://<hostname>/<database>:`
	- `jdbc:mysql://localhost/departamentos`
- Username: `root`
- Password: `contraseñaMySql`

> `Finish`


## **2. Configurar Console Configuration**

> Es una configuración en el IDE (por ejemplo, Eclipse o IntelliJ) que conecta Hibernate con tu proyecto y permite interactuar con la base de datos desde el entorno de desarrollo.

• Facilita la visualización de las tablas y los datos directamente desde el IDE.
• Permite validar que Hibernate se conecta correctamente a la base de datos antes de ejecutar la aplicación.

---
### Proceso

> Dentro de `com.eperez.mvc.model.entity`

![[Pasted image 20250124184634.png]]

> Main

- Hibernate Version: `< 5`
	- `4.3`
- Project: `Nombre del proyecto`
	- APIDepartamentos
- Database connection: `[Hibertnate configured  connection]`
- Property file: 
- Configuration file: `ruta donde creamos el archivo hibernate.cfg.xml`
- Persistence unit:

![[Pasted image 20250124185040.png]]

> Options

- Database dialect: `MySQL`


## **3. Ingeniería inversa**

> Hibernate puede analizar las tablas existentes en la base de datos y generar automáticamente clases Java correspondientes a esas tablas (también conocidas como **entidades**).

• Ahorras tiempo, ya que no tienes que escribir manualmente las clases que representan las tablas.
• Garantiza que las clases estén correctamente mapeadas a las tablas de la base de datos, reduciendo errores.

---
### Proceso

> Dentro de `com.eperez.mvc.model.entity`

![[Pasted image 20250124185245.png]]

- Console configuration: Buscar la que tiene el nombre del proyecto
	- `APIDepartamentos`
- Refresh
- Database schema: Buscar las tablas de la base de datos a incluir

![[Pasted image 20250124185342.png]]


## **4. Code Generation Configuration**

> Configuración para que Hibernate genere automáticamente:

• Archivos de mapeo XML o anotaciones.
• Clases de entidades basadas en las tablas de la base de datos.
• Archivos adicionales como controladores o repositorios.

• Automatiza la creación de código repetitivo y propenso a errores.
• Genera una base de código consistente, lista para ser utilizada en operaciones CRUD (crear, leer, actualizar y eliminar).

---
### Proceso

> `Run > Hibernate Code Generation > Hibernate Code Generation Configueretions`

![[Pasted image 20250124185700.png]]

> Clic sobre `Hibernate Code Generation > New Configuration` (icono de página en blanco).

![[Pasted image 20250124185944.png]]

- Name: `Anotaciones`

> Main

- Console configuration: Nombre del proyecto
	- `APIDepartamentos`
- Output directory: Proyecto / src / main / java
	- `/APIDepartamentos/src/main/java`
- Marcar casilla: `Reverse engineer from JDBC Connection`
- Package: `com.eperez.mvc.model.entity`
- reveng.xml: > Use existing
	- `/APIDepartamentos/src/main/java/com/eperez/mvc/model/entity/hibernate.reveng.xml`

![[Pasted image 20250124190907.png]]

> Exporters

- General settings:
	- Marcar `Generate EJB3 annotations`
	- Exporters:
		- `Domain code (.java)
		- `Hibernate XML Configuration (.cfg.xml)


## 5. Corregir errores en las entidades

> Abrir la clase que nos ha generado `Departamentos.java`

### **1. Cambiar javax por jakarta en los imports**

• **Por qué**: Hibernate en sus versiones más recientes utiliza el estándar **Jakarta EE**, que sustituye a **Java EE**. Por eso, necesitas cambiar los paquetes que comienzan con javax por jakarta.

• **Cómo hacerlo**: En todas las clases generadas por Hibernate, busca y reemplaza:

```
import javax.persistence.*;
```

por:

```
import jakarta.persistence.*;
```


- Cambiar java por jakarta en los imports
```java
import javax.persistence.Table;   // error
import jakarta.persistence.Table; // corrección
```

### **2. Agregar un default serialVersionUID a las clases**

• **Por qué**: Las clases generadas por Hibernate suelen implementar la interfaz Serializable para que puedan ser enviadas a través de redes o almacenadas en disco. El campo serialVersionUID es necesario para garantizar la compatibilidad entre versiones de la clase durante la serialización.

• **Cómo hacerlo**:

Eclipse o IntelliJ te ofrece una sugerencia para agregar automáticamente el campo serialVersionUID. Si lo haces manualmente, puedes añadir algo como:

```
private static final long serialVersionUID = 1L;
```

### **3. Corregir el uso del Set**

> Cuando utilizamos un Set en una clase generada por Hibernate, este representa una colección de elementos relacionados, generalmente en una relación de tipo **uno a muchos** o **muchos a muchos**. En estos casos, debes especificar el tipo de objeto que almacenará el Set, porque Hibernate necesita saber exactamente qué tipo de entidad está relacionado con la clase principal.

Cuando Hibernate genera un Set `<?>`, coloca un comodín (?) porque no está seguro del tipo exacto de los objetos relacionados. Necesitas reemplazar este comodín con la clase relacionada.

• **Por qué**: Hibernate necesita conocer el tipo específico de la relación para manejar correctamente las operaciones de persistencia (guardar, actualizar, eliminar).

• **Cómo hacerlo**: Si tienes una clase Departamentos relacionada con una clase Profesores. El Set `<?>` se verá algo así:

```java
private Set<Profesores> profesoreses;
```

Debes corregirlo especificando el tipo de entidad que almacena, en este caso Profesores:

```java
private Set<Profesores> profesoreses = new HashSet<Profesores>(0);
```

Además, asegúrate de que el mapeo de la relación esté definido correctamente. Por ejemplo:

```java
@OneToMany(mappedBy = "departamento")
private Set<Profesores> profesoreses;
```


### 4. Repetir el proceso con el resto de clases

> Desde la clase de `Profesores.java`

1. Corregir imports `javax`> `jakarta`
2. Agregar un default `serialVersionUID` a las clases
3. Guardar cambios



